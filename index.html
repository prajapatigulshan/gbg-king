<!-- Save as index.html and open in browser -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple Parkour Starter</title>
<style>
  html,body { height:100%; margin:0; background:#2e2b2b; display:flex; align-items:center; justify-content:center; font-family:Arial, sans-serif; color:#fff; }
  #game { background:#87ceeb; width:900px; height:450px; box-shadow:0 8px 30px rgba(0,0,0,.6); position:relative; overflow:hidden; }
  canvas { display:block; background: linear-gradient(#87ceeb,#66b0e6); }
  #ui { position:absolute; left:12px; top:8px; font-weight:bold; text-shadow:0 1px 2px rgba(0,0,0,.6); }
  #hint { position:absolute; right:12px; top:8px; opacity:.9; font-size:13px; }
</style>
</head>
<body>
  <div id="game">
    <div id="ui">Score: <span id="score">0</span></div>
    <div id="hint">Use ← → to move, ↑ or Space to jump</div>
    <canvas id="c" width="900" height="450"></canvas>
  </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const W = canvas.width, H = canvas.height;

let keys = {};
addEventListener('keydown', e => keys[e.code] = true);
addEventListener('keyup', e => keys[e.code] = false);

// Player
const player = {
  x: 120, y: 300,
  w: 28, h: 40,
  vx: 0, vy: 0,
  speed: 3.6,
  jumpPower: 10.5,
  onGround: false,
  color: '#ffdd57'
};

// Gravity
const gravity = 0.5;
const friction = 0.86;

// Platforms (x,y,w,h). We'll generate moving platforms ahead
let platforms = [
  {x:0, y:400, w:900, h:50}, // ground
  {x:320, y:330, w:120, h:16},
  {x:520, y:260, w:140, h:16},
  {x:760, y:200, w:100, h:16}
];

// For scrolling effect: world offset
let cameraX = 0;
let score = 0;
let gameSpeed = 1.2;

function rectsOverlap(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

function update(){
  // Input
  if(keys['ArrowLeft'] || keys['KeyA']) player.vx = -player.speed;
  else if(keys['ArrowRight'] || keys['KeyD']) player.vx = player.speed;
  else player.vx *= 0.8;

  // Jump
  if((keys['ArrowUp'] || keys['Space'] || keys['KeyW']) && player.onGround){
    player.vy = -player.jumpPower;
    player.onGround = false;
  }

  // Physics
  player.vy += gravity;
  player.x += player.vx;
  player.y += player.vy;

  // Simple collision with platforms
  player.onGround = false;
  for(let p of platforms){
    // check AABB collision from top
    const A = {x: player.x, y: player.y, w: player.w, h: player.h};
    const B = {x: p.x - cameraX, y: p.y, w: p.w, h: p.h};
    if(rectsOverlap(A,B)){
      // Resolve collision - place player on top if falling
      if(player.vy > 0 && (player.y + player.h) - p.y < 20){
        player.y = p.y - player.h;
        player.vy = 0;
        player.onGround = true;
      } else {
        // simple horizontal pushback
        if(player.x < p.x - cameraX) player.x = p.x - cameraX - player.w - 0.1;
        else player.x = p.x - cameraX + p.w + 0.1;
        player.vx = 0;
      }
    }
  }

  // Keep player vertically in bounds
  if(player.y > H + 200){ // fell down
    resetGame();
    return;
  }
  if(player.x < 40) player.x = 40;

  // Scroll world to the right as player moves forward
  const forwardThreshold = W * 0.45;
  if(player.x > forwardThreshold){
    const dx = player.x - forwardThreshold;
    player.x = forwardThreshold;
    cameraX += dx;
    // move platforms left visually by increasing cameraX (we already applied)
    score = Math.floor(cameraX / 10);
    document.getElementById('score').innerText = score;
  }

  // generate new platforms as camera moves
  let maxX = Math.max(...platforms.map(p => p.x + p.w));
  while(maxX < cameraX + W + 300){
    const gap = 120 + Math.random()*160 - Math.min(60, score/50);
    const nextW = 70 + Math.random()*140;
    const nextY = 160 + Math.random()*220;
    const newP = { x: maxX + gap, y: nextY, w: nextW, h:16 };
    // Occasionally add moving platform (simplified)
    if(Math.random() < 0.18){
      newP.move = (Math.random() < 0.5) ? 'h' : 'v';
      newP.offset = 0;
      newP.amp = 40 + Math.random()*70;
      newP.speed = 0.015 + Math.random()*0.03;
    }
    platforms.push(newP);
    maxX = newP.x + newP.w;
  }

  // update moving platforms
  for(let p of platforms){
    if(p.move === 'h'){
      p.offset += p.speed * gameSpeed;
      p.x += Math.sin(p.offset) * 0.6; // subtle
    } else if(p.move === 'v'){
      p.offset = (p.offset || 0) + p.speed * gameSpeed;
      p.y += Math.sin(p.offset) * 0.8;
    }
  }

  // remove old platforms behind camera
  platforms = platforms.filter(p => p.x + p.w > cameraX - 300);

}

function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // background simple parallax
  ctx.fillStyle = '#8fd3ff';
  ctx.fillRect(0,0,W,H);

  // draw some clouds (parallax)
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  for(let i=0;i<6;i++){
    const cx = ((i*220) - (cameraX*0.2 % 900));
    ctx.beginPath();
    ctx.ellipse(cx, 80 + (i%2)*15, 40,20,0,0,Math.PI*2);
    ctx.fill();
  }

  // draw platforms
  for(let p of platforms){
    const sx = Math.round(p.x - cameraX);
    ctx.fillStyle = '#6b3';
    ctx.fillRect(sx, p.y, p.w, p.h);
    // platform top highlight
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillRect(sx, p.y, p.w, 3);
  }

  // draw player
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.w, player.h);
  // simple eye
  ctx.fillStyle = '#222';
  ctx.fillRect(player.x + 6, player.y + 10, 6, 6);

  // ground shadow or horizon
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.fillRect(0, H-12, W, 12);
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

function resetGame(){
  // reset variables
  player.x = 120; player.y = 300; player.vx = 0; player.vy = 0; cameraX = 0; score = 0;
  platforms = [
    {x:0, y:400, w:900, h:50},
    {x:320, y:330, w:120, h:16},
    {x:520, y:260, w:140, h:16},
    {x:760, y:200, w:100, h:16}
  ];
  document.getElementById('score').innerText = '0';
}

// start
loop();

</script>
</body>
</html>
